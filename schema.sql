-- Pasar Cepat Supabase Schema
-- Version 1.0

-- This script sets up the entire database schema, including tables,
-- storage buckets, security policies (RLS), and database functions/triggers.
-- To use, copy and paste the entire script into the Supabase SQL Editor and run it.

-- =============================================
-- 1. TABLE CREATION
-- =============================================

-- Profiles table to store public user data, linked to auth.users
CREATE TABLE public.profiles (
    id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    name text NOT NULL,
    email text NOT NULL UNIQUE,
    avatar_url text,
    whatsapp_number text,
    role text DEFAULT 'user'::text NOT NULL,
    wishlist integer[] DEFAULT '{}'::integer[] NOT NULL
);
COMMENT ON TABLE public.profiles IS 'Stores public user profile information.';

-- Products table for all items listed for sale
CREATE TABLE public.products (
    id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    name text NOT NULL,
    price numeric NOT NULL,
    description text,
    image_urls text[] DEFAULT '{}'::text[] NOT NULL,
    category jsonb,
    location jsonb,
    seller_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    contact_info jsonb
);
COMMENT ON TABLE public.products IS 'Stores all products available for sale.';

-- Chat Sessions table to group messages between a buyer and a seller for a product
CREATE TABLE public.chat_sessions (
    id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    product_id bigint NOT NULL REFERENCES public.products(id) ON DELETE CASCADE,
    buyer_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    seller_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    last_message text,
    last_message_timestamp timestamp with time zone,
    CONSTRAINT unique_chat_session UNIQUE (product_id, buyer_id)
);
COMMENT ON TABLE public.chat_sessions IS 'A conversation thread between a buyer and seller about a product.';

-- Chat Messages table for individual messages
CREATE TABLE public.chat_messages (
    id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    session_id bigint NOT NULL REFERENCES public.chat_sessions(id) ON DELETE CASCADE,
    sender_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    text text NOT NULL
);
COMMENT ON TABLE public.chat_messages IS 'Individual messages within a chat session.';
-- Create an index for faster message retrieval
CREATE INDEX idx_chat_messages_session_id ON public.chat_messages(session_id);


-- Reviews table
CREATE TABLE public.reviews (
    id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    product_id bigint NOT NULL REFERENCES public.products(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    rating smallint NOT NULL CHECK (rating >= 1 AND rating <= 5),
    text text
);
COMMENT ON TABLE public.reviews IS 'User reviews for products.';

-- Replies table for sellers to reply to reviews
CREATE TABLE public.replies (
    id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    review_id bigint NOT NULL REFERENCES public.reviews(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    text text NOT NULL
);
COMMENT ON TABLE public.replies IS 'Seller replies to product reviews.';

-- =============================================
-- 2. STORAGE BUCKETS
-- =============================================

-- Bucket for product images
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES ('product-images', 'product-images', true, 10485760, ARRAY['image/jpeg', 'image/png', 'image/webp', 'image/gif'])
ON CONFLICT (id) DO NOTHING;

-- Bucket for user avatars
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES ('avatars', 'avatars', true, 2097152, ARRAY['image/jpeg', 'image/png', 'image/webp'])
ON CONFLICT (id) DO NOTHING;

-- =============================================
-- 3. FUNCTIONS & TRIGGERS
-- =============================================

-- Function to create a new profile when a user signs up
-- This is a more robust way than creating the profile from the client-side.
-- Assumes 'name' is passed in meta_data on signup.
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  INSERT INTO public.profiles (id, name, email, avatar_url)
  VALUES (
    new.id,
    COALESCE(new.raw_user_meta_data->>'name', 'New User'), -- Use name from metadata or a default
    new.email,
    COALESCE(new.raw_user_meta_data->>'avatar_url', 'https://i.pravatar.cc/150?u=' || new.id::text) -- Use avatar from metadata or a default
  );
  return new;
END;
$$;

-- Trigger to call the function after a new user is created in auth.users
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Helper function to check if the current user has an 'admin' role
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS boolean
LANGUAGE plpgsql
AS $$
DECLARE
  user_role text;
BEGIN
  IF auth.uid() IS NULL THEN
    RETURN false;
  END IF;
  SELECT role INTO user_role FROM public.profiles WHERE id = auth.uid();
  RETURN user_role = 'admin';
END;
$$;


-- =============================================
-- 4. ROW LEVEL SECURITY (RLS)
-- =============================================

-- Enable RLS on all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.chat_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.chat_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reviews ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.replies ENABLE ROW LEVEL SECURITY;

-- --- Profiles Policies ---
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update their own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);
CREATE POLICY "Admins can manage all profiles." ON public.profiles FOR ALL USING (public.is_admin());
-- Drop default policies that might exist
DROP POLICY IF EXISTS "Enable read access for all users" ON public.profiles;

-- --- Products Policies ---
CREATE POLICY "Products are viewable by everyone." ON public.products FOR SELECT USING (true);
CREATE POLICY "Authenticated users can create products." ON public.products FOR INSERT WITH CHECK (auth.role() = 'authenticated' AND auth.uid() = seller_id);
CREATE POLICY "Users can update their own products." ON public.products FOR UPDATE USING (auth.uid() = seller_id);
CREATE POLICY "Users can delete their own products." ON public.products FOR DELETE USING (auth.uid() = seller_id);
CREATE POLICY "Admins can manage all products." ON public.products FOR ALL USING (public.is_admin());
DROP POLICY IF EXISTS "Enable read access for all users" ON public.products;

-- --- Chat Sessions Policies ---
CREATE POLICY "Users can view their own chat sessions." ON public.chat_sessions FOR SELECT USING (auth.uid() = buyer_id OR auth.uid() = seller_id);
CREATE POLICY "Buyers can create chat sessions." ON public.chat_sessions FOR INSERT WITH CHECK (auth.uid() = buyer_id);
CREATE POLICY "Users can update their own chat sessions (for last_message)." ON public.chat_sessions FOR UPDATE USING (auth.uid() = buyer_id OR auth.uid() = seller_id);
CREATE POLICY "Admins can view all chat sessions." ON public.chat_sessions FOR SELECT USING (public.is_admin());
DROP POLICY IF EXISTS "Enable read access for all users" ON public.chat_sessions;

-- --- Chat Messages Policies ---
CREATE POLICY "Users can view messages in their chats." ON public.chat_messages FOR SELECT USING (session_id IN (SELECT id FROM public.chat_sessions WHERE auth.uid() = buyer_id OR auth.uid() = seller_id));
CREATE POLICY "Users can send messages in their chats." ON public.chat_messages FOR INSERT WITH CHECK (auth.uid() = sender_id AND session_id IN (SELECT id FROM public.chat_sessions WHERE auth.uid() = buyer_id OR auth.uid() = seller_id));
CREATE POLICY "Admins can view all chat messages." ON public.chat_messages FOR SELECT USING (public.is_admin());
DROP POLICY IF EXISTS "Enable read access for all users" ON public.chat_messages;

-- --- Reviews Policies ---
CREATE POLICY "Reviews are public." ON public.reviews FOR SELECT USING (true);
CREATE POLICY "Authenticated users can create reviews on products they dont own." ON public.reviews FOR INSERT WITH CHECK (auth.role() = 'authenticated' AND auth.uid() = user_id AND NOT EXISTS (SELECT 1 FROM products WHERE id = product_id AND seller_id = auth.uid()));
CREATE POLICY "Users can delete their own reviews." ON public.reviews FOR DELETE USING (auth.uid() = user_id);
CREATE POLICY "Admins can manage all reviews." ON public.reviews FOR ALL USING (public.is_admin());
DROP POLICY IF EXISTS "Enable read access for all users" ON public.reviews;

-- --- Replies Policies ---
CREATE POLICY "Replies are public." ON public.replies FOR SELECT USING (true);
CREATE POLICY "Sellers can reply to reviews on their products." ON public.replies FOR INSERT WITH CHECK (auth.uid() = user_id AND user_id = (SELECT p.seller_id FROM public.products p JOIN public.reviews r ON p.id = r.product_id WHERE r.id = review_id));
CREATE POLICY "Users can delete their own replies." ON public.replies FOR DELETE USING (auth.uid() = user_id);
CREATE POLICY "Admins can manage all replies." ON public.replies FOR ALL USING (public.is_admin());
DROP POLICY IF EXISTS "Enable read access for all users" ON public.replies;


-- =============================================
-- 5. STORAGE POLICIES
-- =============================================

-- --- Product Images Policies ---
CREATE POLICY "Allow public read access to product images" ON storage.objects FOR SELECT USING (bucket_id = 'product-images');
CREATE POLICY "Allow authenticated users to upload product images" ON storage.objects FOR INSERT WITH CHECK (bucket_id = 'product-images' AND auth.role() = 'authenticated');
CREATE POLICY "Allow owners to delete their product images" ON storage.objects FOR DELETE USING (bucket_id = 'product-images' AND auth.uid() = (SELECT seller_id FROM products WHERE id = ((storage.foldername(name))[2])::bigint));

-- --- Avatars Policies ---
CREATE POLICY "Allow public read access to avatars" ON storage.objects FOR SELECT USING (bucket_id = 'avatars');
CREATE POLICY "Allow users to upload their own avatar" ON storage.objects FOR INSERT WITH CHECK (bucket_id = 'avatars' AND auth.uid() = (storage.foldername(name))[1]::uuid);
CREATE POLICY "Allow users to update their own avatar" ON storage.objects FOR UPDATE USING (bucket_id = 'avatars' AND auth.uid() = (storage.foldername(name))[1]::uuid);